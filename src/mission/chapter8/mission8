- **미션 기록**
    - ⚡이슈 No.1
        
        **`이슈`**
        
        👉 [ErrorStatus 작성]
        
        **`문제`**
        
        👉 [ErrorStatus에서 enum이 워크북대로 했는데도 오류가 남]
        
        **`해결`**
        
        👉  [AllArgsConstructor 애노테이션을 사용하면 지역변수가 선언되어 있는 순서대로 생성자를 만든다
        
        → 따라서 매개변수 순서대로 지역변수를 선언해주면 해결]
        
        **`참고레퍼런스`**
        
        - [이것저것 해봄]
    - RestControllerAdvice의 장점, 불편한 점
        - 장점
            - HttpServletRequest나 WebRequest 등을 얻을 수 있으며 반환 타입으로는 ResponseEntity, String, void 등 자유롭게 활용할 수 있음
            - 컨트롤러에서 예외를 직접 처리하지 않아도 됩니다.
                
                예외가 발생하면 `@(Rest)ControllerAdvice`가 선언된 클래스에서 해당 예외를 캐치하고 적절한 응답을 반환합니다.
                
            - 예외에 따라 다른 처리 로직을 적용할 수 있습니다.
                
                `@ExceptionHandler` 어노테이션을 사용하여 특정 예외에 대한 `핸들러 메서드`를 정의할 수 있습니다.
                
                예를 들어, NullPointerException이 발생하면 400 에러 코드와 에러 메시지를 반환하고, IOException이 발생하면 500 에러 코드와 에러 메시지를 반환하는 등의 로직을 구현할 수 있습니다.
                
            - 공통적인 예외 처리 로직을 재사용할 수 있습니다.
                
                `@(Rest)ControllerAdvice`가 선언된 클래스는 모든 컨트롤러에 적용됩니다. 따라서 여러 컨트롤러에서 발생하는 동일한 예외에 대해 한 곳에서 처리할 수 있습니다.
                
        - 없으면 불편한 점(구글링은 잘 안나와서 지피티 돌려봤습니다)
            1. **중복 코드 증가**:
                - 각 컨트롤러마다 예외 처리를 개별적으로 구현해야 하므로, 동일한 예외 처리 코드가 여러 컨트롤러에 중복될 가능성이 높습니다. 이는 코드 유지보수성을 떨어뜨리고, 코드의 일관성을 유지하기 어렵게 만듭니다.
            2. **유지보수 어려움**:
                - 예외 처리 로직을 변경해야 할 경우, 모든 컨트롤러에서 해당 로직을 일일이 찾아 수정해야 합니다. 이는 많은 시간과 노력이 필요하며, 실수로 일부 컨트롤러에서 수정이 누락될 위험이 있습니다.
            3. **일관성 부족**:
                - 예외 처리 방식이 컨트롤러마다 다를 수 있어, 클라이언트가 예외 상황을 예측하기 어렵습니다. 이는 API의 일관성을 떨어뜨리고, 사용자 경험을 저해할 수 있습니다.
            4. **글로벌 설정의 어려움**:
                - **`RestControllerAdvice`**를 사용하면 특정 예외에 대한 전역적인 처리를 한 곳에서 설정할 수 있어 편리합니다. 이를 사용하지 않으면 전역 설정이 어려워지고, 특정 예외에 대한 일관된 처리가 어려워집니다.
