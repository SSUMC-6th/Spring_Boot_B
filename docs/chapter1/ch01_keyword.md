## TCP
:TCP와 UDP는 인터넷에서 데이터를 전송하기 위해  TCP/IP의 4계층에서 사용하는 두가지 주요 프로토콜이다


📌 **TCP(Transmission Control Protocol)의 특징**
    
    - 신뢰성있는 연결 지향 프로토콜 : 데이터가 순서대로, 손실없게, 정확하게 도착하는 것을 보장함
    - 3-way-handshaking :SYN- SYN-ACK,ACK 으로 연결 수립 
    - 흐름제어, 혼잡제어
    - 오류 검출 및 재전송
    
✅  TCP는 신뢰성과 순서가 중요한 통신에 주로 사용된다
    ex) 웹 페이지 로딩, 이메일 전송, 파일 전송 등

    
## UDP

📌 **UDP(User Datagram Protocol)의 특징**

  - 비연결 지향 프로토콜 : 연결설정 없이 데이터를 전송함
  - 오베헤드↓: TCP에 비해 헤더가 간단, 연결 설정 과정 없음
  - 신뢰성 X: 데이터의 도착 보장 X, 패킷 손실과 순서 바뀜 발생 가능
  - 빠른 전송: 오버헤드가 적어 빠르게 데이터를 전송할 수 O

✅  UDP는 실시간 통신 또는 패킷 손실을 감내할 수 있는 통신에 주로 사용한다
  ex) 실시간 비디오 및 오디오 스트리밍, 온라인 게임 등

  
## 시스템콜
📌 **시스템 콜(System call) 이란?**
    : 응용 프로그램의 요청에 따라 OS의 kernel에 접근하기 위한 인터페이스

✅ 시스템 콜이 필요한 이유
    - 유저 레벨에서의 응용 프로그램 만으로는 많은 기능을 구현하기 힘듦
    - 보안이 필요한경우, 커널의 시스템콜을 호출하여 커널로 접근해야함

    
## 하드웨어 인터럽트

📌 **하드웨어 인터럽트**
    : 하드웨어(키보드,마우스,프린터,네트워크 카드)가 발생시키는 interrupt

    ex) 사용자가 키보드를 누르면 하드웨어 인터럽트 신호를 보내 CPU가 현재 작업을 잠시멈추고 키보드 입력을 받도록함


↔️ **소프트웨어 인터럽트**
    : 소프트웨어가 발생시킨 interrupt

    ex) 어떤 응용 프로그램이 파일을 읽고자 할때, OS에 서비스를 요청(system call)하기 위해 인터럽트를 발생시킴


## 리눅스의 파일과 파일 디스크립터
- **리눅스에서의 파일이란?**
    
    리눅스에서는 모든 것을 파일로 간주한다
    
    예를 들어 텍스트 파일, 실행 파일, 디렉토리, 하드웨어 장치 등 모든게 다 파일이다.
    
    → 즉, 데이터를 저장하고 프로그램과 상호작용하는데 필요한 기본적인 정보 단위!
    

- **파일 디스크립터란(FD)?**
    
    : 리눅스/ 유닉스 계열의 시스템에서 프로세스가 파일을 참조하는데 사용하는 정수값
    
    → 파일을 지칭하는 인덱스와 포인터 같은 것
    
    → 프로세스가 파일을 열면, 파일 디스크립터를 할당함
    
    ⇒ 이때, 파일 디스크립터 테이블에서 사용하지 않는 가장 낮은 번호를 해당 파일에 할당

  
## socket() 시스템콜
    
 ```c
  socket(domain, type, protocol );  
  ```
 
 ```c
 int socket_descriptor = socket(AF_INET, SOCK_STREAM, 0);
  // socket의 FD(파일 디스크립터)를 반환해준다.
  ```
    
 - **socket()함수의 역할**
        
    소켓을 생성함!
        
    → 해당 소켓을 가리키는 소켓 디스크립터를 반환한다.
        
        
- **socket()함수의 파라미터**
        
        
  | domain | AF_UNIX(프로토콜 내부에서), AF_INET(IPv4), AF_INET6(IPv6) |
   | --- | --- |
  | type | SOCK_STREAM(TCP), SOCK_DGRAM(UDP), SOCK_RAW(사용자 정의) |
   | protocol |  0(시스템 지정), IPPROTO_TCP(TCP-6), IPPROTO_UDP(UDP-7) |
  |  |  |

        
## bind() 시스템콜
    
 ```c
  bind(sockfd, sockaddr, socklen_t)
 ```
    
- **bind() 함수의 역할**
        
  socket()함수로 생성한 소켓의 IP주소와 PORT번호를 부여해주는 시스템콜
        
        
- **bind() 함수의 파라미터**
        
        
   | sockfd | 소켓의 FD |
   | --- | --- |
   | sockaddr | IP주소, PORT번호를 담은 구조체 |
   | socklen_t | 위 구조체의 메모리 크기 |
    
 **[ 📣 중요 ]** 클라이언트에서는 포트 번호가 자동으로 부여되기에, bind()함수는 서버에서만 사용됨

      
## listen() 시스템콜

```c
listen(sockfd,backlog)
```
    
- **listen()함수의 역할**
        
   TCP의 백로그 큐(대기열)를 만들어줌
  
        
- **listen()함수의 파라미터**

   | sockfd | 소켓의 FD |
  | --- | --- |
  | backlog | TCP 백로그 큐 크기 |

  
## accept() 시스템콜

```c
 int accept(sockfd,sockaddr,socklen_t);
 ```
    
 - **accept() 함수의 역할**
        
   backlog queue에서 syn을 보내와 대기 중인 요청을 선입선출로 하나씩 연결에 대한 수립을 해줌
     
- **accept() 의 파라미터**
        
    
   | sockfd | 소켓의 FD |
   | --- | --- |
   | sockaddr | 큐에서 꺼내온 클라이언트의 주소 정보 |
   | socklen_t | 위 구조체의 메모리 크기 |

  
## 멀티 프로세스

📌 ***멀티프로세스란?***

멀티프로세스는 컴퓨터가 동시에 여러 프로그램(프로세스)을 실행하는 기능!

컴퓨터의 여러 자원(CPU, 메모리 등)을 효율적으로 사용하여, 하나의 프로그램이 다른 프로그램의 작업을 방해하지 않으면서 동시에 여러 작업을 수행할 수 있게 해줌



## 병렬 처리

📌 ***병렬 처리란?***

병렬 처리는 컴퓨터가 여러 계산 작업을 동시에 수행하는 것!

작업을 여러 부분으로 나누고, 각 부분을 동시에 다른 프로세서(또는 CPU의 코어)에서 실행하여 전체 작업을 더 빠르게 완료하는 방식
