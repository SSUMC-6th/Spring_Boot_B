서버(server)란?
	OS를 통해 동작하는 프로세스이며 클라이언트 역할의 프로세스와 소켓을 통해 IPC
		IPC는?
			Inter-Process communication으로 다른 컴퓨터의 프로세스와 데이터 교환 및 통신 하기위한 메커니즘을 의미함
			TCP/IP, UDP, REST등 방식으로 구현함

시스템 콜(system call)이란?
	먼저 system call를 알기 전에 우리 프로그램이 가지는 두가지 권한에 대해서 알아야할 것 같다.
	프로세스가 가지는 권한은 2가지가 있는데 유저 모드와, 커널 모드 두가지로 나뉜다. 이 모드에 따라서 접근할 수 있는 자원에 대해서 권한을 갖을 수 있다.
	왜 이렇게 두가지로 모드를 나눴을까?
		컴퓨터 시스템에 대한 보안과 안전성을 위해서라고 할 수 있다. 유저 모드에서는 직접적으로 시스템에 자원에 대해서 접근할 수 없으며 반드시 커널모드를 통해서 접근해야한다. 이를 통해 악의적인 프로그램이 실행되어 컴퓨터를 망가뜨리는 것을 방지할 수 있다. 혹은 아직 미성숙한 프로그래머가 잘못된 시스템 콜 호출로 인해 컴퓨터가 망가뜨리는 것 또한 방지할 수 있다.
	우리가 주로 사용하는 응용 프로그램은 유저모드로 실행되며 시스템의 자원에 직접적인 접근이 불가능하다. 이와 반면 커널 모드는 커널이 실행되는 곳으로 운영 체제의 모든 기능이 실행되고 시스템의 하드웨어 및 메모리에 대해 완전한 제어권을 갖는다.
	**즉 시스템 콜은 유저 모드에서는 실행하지 못하는 코드를 실행하기 위해 커널에게 대신 실행해 줄 것을 요청하는 것이다.**

아이피 주소(IP address)와 포트 번호(port number)
	IP address
		아이피 주소는 수많은 컴퓨터가 연결된 인터넷 세상 속에서 서로를 식별하기 위해 가지는 고유한 번호이다. 진짜 특정 기기를 식별하기 위해서는 MAC address가 필요하지만, IP주소는 정확한 동 호수 까지는 아니더라도 어느 아파트인지 식별할 수 있게 해준다. 32bit로 이루어져 있고 xxx.xxx.xxx.xxx와 같은 형태를 가진다.
			MAC address는 기기가 갖는 고유한 주소로 총 48bit로 구성되어 있으며 24bit는 제조회사 번호, 24bit는 기기에게 부여되는 번호이다.
		 IP address는 총 32 bit으로 구성되어 있는데 대략 42억개의 컴퓨터를 식별할 수 있다. 현대는 2024년 4월 기준 약 80억명의 인구가 있는데 한 사람씩 하나의 IP를 사용한다고 하더라도 이는 부족한 숫자이다. 이를 해결하기 위해 Ip의 bit수를 증가시킨 IPv6나 하나의 공인 IP를 여러개의 컴퓨터가 나눠서 사용하는 NAT기술들이 나타나고 있다.
	Port number
		위 IP address가 인터넷 세상 속 컴퓨터를 인식했다면 port number는 컴퓨터에서 실행되고 있는 process를 인식하는 것이다. 하나의 컴퓨터에서 하나의 프로그램 만이 다른 컴퓨터와 통신 하고 있는 것이 아니기 때문에 다양하게 네트워크 통신을 하는 프로세스들 사이에서 어떤 프로세스에게 온 데이터인지 식별하기 위해서는 port number가 필요하다. port number는 0 ~ 65535까지 이루어져 있고 저 안에서 할당하여 사용할 수 있지만 몇몇 port number는 well known port number라고 해서 어떤 용도로 쓰자고 약속된 port number가 존재한다. 예를들어 80(http), 443(https)등이 있다.
	Ip address + Port number
		이 둘을 합쳐서 표현하면  xxx.xxx.xxx.xxx:yyyyy라고 표현할 수 있다.

데이터 송수신 과정
	송신(send)
		 process -> write(data) -> socket -> transport(TCP,UDP) -> network(IP address) -> data link(MAC address) -> physical layer -> Ethernet ... -> destination
	수신(receive)
		~ physical -> driver -> stack -> socket -> process

소켓(socket)
	일단 소켓이 뭔지부터 알아보자
		소켓은 통신을 위한 기본적인 인터페이스로 프로세스들이 데이터를 송수신 할 수 있도록 인터페이스를 제공하는 존재다. 한마디로 다른 프로세스와 통신하려고 쓰는 인터페이스다. transport 계층의 protocol인 TCP혹은 UDP와 함께 작동한다.
	TCP
		연결지향적이고, 흐름 제어와 혼잡 제어를 하여 데이터가 무사히 상대 process에 전달 될 수 있도록 하는 protocol이다.
	UDP
		반면 UDP는 위 TCP와 다르게 어떻게 도착하는지, 상대가 준비가 되어있는지는 관심 없고 그저 데이터를 보내면 끝이다. 장점으로는 위 과정을 하지 않기 때문에 더 빠른 데이터 전송이 가능하다.
	socket() 시스템 콜
		`int socket(domain, type, protocol)`형태이다.
			domain은 IPv4로 통신할지 IPv6로 통신할지 결정한다.
			type은 UDP방식으로 할지 TCP방식으로 통신할지 결정한다.
			protocol은 소켓에 사용할 프로토콜을 지정한다.
		return type이 int인게 특이한데 이는 파일 디스크럽터(file descriptor)라고 하는 것이다. 
			파일 디스크럽터는 입출력 리소스에 대한 추상적인 참조로 정수로 표현된다. 이 정수로 표현된 파일 디스크럽터로 리소스를 식별할 수 있고, 읽기, 쓰기, 닫기 등의 작접을 수행한다. 
		리눅스는 모든 것을 파일로 취급하는데 소켓 또한 파일로 취급하고, 파일 디스크럽터로 소켓을 다룰  수 있다. 실패시 -1를 return하고 이를 통해 예외를 식별할 수 있기 때문에 예외 처리를 해줘야한다.
	bind() 시스템 콜
		`int bind(sockfd, sockaddr *, socklen_t)`형태이다.
			sockfd는 binding할 소켓의 파일 디스크럽터다.
			sockaddr은 bind할 아이피주소, 포트번호를 담아 둔 구조체다.
				`struct sockaddr{`
					`unsigned short sa_family // AF_INET or AF_INET6`
					`char sa_data\[14] // IP address`
					`// 포트번호는 sockaddr_in 구조체를 사용하면 넣을 수 있다.`
				`}`
		bind()를 사용하여 소켓에 IP address와 Port number를 부여할 수 있다. 
		클라이언트에서는 특정 port에 binding하여 통신할 필요가 없기 때문에 서버만 bind()를 사용한다.
	listen() 시스템 콜
		`int listen(int sockfd, int backlog)`형태다
			sockfd는 소켓의 파일 디스크럽터 번호다.
			backlog는 몇개의 연결 대기를 허용할지 지정하는 파라미터다. backlog queue의 크기를 결정한다.
		이 시스템콜을 사용하고 나면 소켓은 backlog에 입력받은 크기만큼 backlog queue를 만들고 클라이언트의 연결 요청을 기다린다. 
		listen중인 소켓에 클라이언트에서 connect()를 사용하면 syn packet이 날아온다. 이를 받고 서버에서는 accept함수를 통해 클라이언트와 연결 처리를 한다.
	accept() 시스템 콜
		`int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)`
			sockfd는 연결을 수락할 서버 소켓의 파일 디스크럽터다.
			\*addr는 클라이언트의 주소를 저장할 구조체 포인터다.
			addrlen addr의 크기를 나타낸다.
		accept는 backlog queue에서 대기중인 연결에 대한 요청을 처리해준다.
		클라이언트의 주소에 대한 정보는 backlog에 저장되어있던 것을 가져와 저장한다.
		요청이 들어온 클라이언트와 연결을 하기위한 소켓을 만들어 이를 반환해준다. 서버는 이 새로 생성된 소켓을 통해 연결된 클라이언트와 통신한다.
		accept는 블로킹 함수로 연결이 오기 전까지 대기한다 이 경우 accept와 클라이언트의 송신 처리를 하나의 프로세스에서 그냥 적용해버리면 accept()의 블로킹에 막혀 서버의 응답이 지연될 수도 있다. 그렇기 때문에 서버 응답 속도를 위해서 추가적인 처리가 필요하다.
		혹은 연결 후 응답로직까지 다 처리하고 다음 연결을 처리한다면 이 또한 연결이 원활히 될 수 없다.
	멀티 프로세스
		멀티 프로세스는 여러개의 프로세스를 만들어서 각각의 역할을 수행하도록 하는 것이다.
		멀티 프로세스를 사용하기 위해는 fork()함수를 알아야한다.
			`pid_t fork(void)`
			fork함수는 부모와 똑같은 자식을 만든다. 이 때 PC값 또한 똑같이 만들어서 부모가 fork를 호출한 시점과 같은 시점의 코드를 수행한다.
			fork()함수 호출시 pid값을 반환하는데 이 때 자식 프로세스면 이 값이 0이고, 부모면 0이 아니다. 로직상 이 점을 활용하여 부모와 자식을 구분하여 코드를 작성한다.
			부모 프로세스는 자식 프로세스가 종료되면 나머지 처리를 해줘야하기 때문에 waitpid나 signal을 이용해 자식의 종료를 인식하고 처리해줘야한다.
		멀티 프로세스를 통해 부모 프로세스는 클라이언트의 연결을 받는 역할을 수행하고, 자식 프로세스는 연결된 클라이언트로 부터 오는 요청들을 처리하도록 구현할 수 있다. 이 때 recv()와 send()가 사용된다.
		
		
	
	 
	